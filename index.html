<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Galaga Bar Blast</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      color: white;
      font-family: sans-serif;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #111;
      border: 2px solid #ffcc00;
      touch-action: none;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      font-size: 52px;
      pointer-events: none;
      z-index: 10;
    }
    #score {
      color: red;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="480" height="640"></canvas>
<div id="hud">
  <span id="score">100</span>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const drinkEmojis = ["üç∫", "üç∑", "ü•É", "üç∏", "üçπ"];
  const player = { x: canvas.width / 2 - 15, y: canvas.height - 50, width: 30, height: 30 };
  const bullets = [];
  const enemies = [];
  const powerUps = [];
  let score = 100;
  let highScore = 100;
  const maxScore = 100;
  let shootCooldown = 0;
  let extraStreams = 0;
  let enemySpawnRate = 1000;
  let powerUpBaseSpeed = 1;
  let lastSpawnTime = 0;
  let lastPowerUpTime = Date.now();
  const pizzaDropInterval = 30000;

  function drawPlayer() {
    ctx.fillStyle = "#00ffcc";
    ctx.fillRect(player.x, player.y, player.width, player.height);
  }

  function drawBullet(bullet) {
    ctx.fillStyle = "#ffff00";
    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
  }

  function drawEnemy(enemy) {
    ctx.font = "28px Arial";
    ctx.fillText(enemy.emoji, enemy.x, enemy.y);
  }

  function drawPowerUp(p) {
    ctx.font = "64px Arial";
    ctx.fillText("üçï", p.x - 32, p.y + 32);
  }

  function spawnEnemy() {
    const emoji = drinkEmojis[Math.floor(Math.random() * drinkEmojis.length)];
    enemies.push({
      x: Math.random() * canvas.width,
      y: -30,
      emoji: emoji,
      speed: 0.5,
      health: 1
    });
  }

  function spawnPowerUp() {
    powerUps.push({
      x: Math.random() * (canvas.width - 64),
      y: -64,
      size: 64,
      speed: powerUpBaseSpeed
    });
  }

  function shoot() {
    if (shootCooldown <= 0) {
      const centerX = player.x + player.width / 2 - 2;
      bullets.push({ x: centerX, y: player.y, width: 4, height: 10, speed: 6 });
      for (let i = 1; i <= extraStreams; i++) {
        bullets.push({ x: centerX - i * 10, y: player.y, width: 4, height: 10, speed: 6 });
        bullets.push({ x: centerX + i * 10, y: player.y, width: 4, height: 10, speed: 6 });
      }
      shootCooldown = 80;
    } else {
      shootCooldown -= 16;
    }
  }

  function update() {
    const now = Date.now();

    if (now - lastSpawnTime > enemySpawnRate) {
      const spawnCount = 5 + Math.floor(Math.pow(score, 0.75) / 5);
      for (let i = 0; i < spawnCount; i++) {
        spawnEnemy();
      }
      lastSpawnTime = now;
    }

    if (now - lastPowerUpTime > pizzaDropInterval) {
      spawnPowerUp();
      lastPowerUpTime = now;
    }

    shoot();

    bullets.forEach((b, bi) => {
      b.y -= b.speed;
      if (b.y < 0) bullets.splice(bi, 1);
    });

    enemies.forEach((e, ei) => {
      e.y += e.speed;
      if (e.y > canvas.height) {
        enemies.splice(ei, 1);
        score--;
        if (score > highScore) highScore = score;
        document.getElementById("score").textContent = score;
        if (score <= 0) {
          alert("Game Over! Highest Score This Session: " + highScore);
          document.location.reload();
        }
      }
    });

    bullets.forEach((b, bi) => {
      enemies.forEach((e, ei) => {
        if (
          b.x < e.x + 24 &&
          b.x + b.width > e.x &&
          b.y < e.y + 24 &&
          b.y + b.height > e.y
        ) {
          bullets.splice(bi, 1);
          e.health--;
          if (e.health <= 0) {
            enemies.splice(ei, 1);
            score++;
            if (score > highScore) highScore = score;
            document.getElementById("score").textContent = score;
          }
        }
      });
    });

    powerUps.forEach((p, i) => {
      p.y += p.speed;
      if (
        player.x < p.x + p.size &&
        player.x + player.width > p.x &&
        player.y < p.y + p.size &&
        player.y + player.height > p.y
      ) {
        extraStreams++;
        powerUps.splice(i, 1);
      } else if (p.y > canvas.height) {
        powerUps.splice(i, 1);
      }
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPlayer();
    bullets.forEach(drawBullet);
    enemies.forEach(drawEnemy);
    powerUps.forEach(drawPowerUp);
  }

  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    player.x = mouseX - player.width / 2;
    player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
  });

  canvas.addEventListener("touchmove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const touchX = e.touches[0].clientX - rect.left;
    player.x = touchX - player.width / 2;
    player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
    e.preventDefault();
  }, { passive: false });

  gameLoop();
</script>

</body>
</html>
